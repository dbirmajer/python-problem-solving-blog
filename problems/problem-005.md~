---
title: "Project Euler Problem 5: Smallest Multiple"
date: 2025-08-09
categories: [project-euler, python]
tags: [lcm, gcd, number-theory, functools, reduce]
---

## Problem Statement

2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

## Understanding the Problem

We need to find the **Least Common Multiple (LCM)** of all numbers from 1 to 20.

For example, with numbers 1 to 10:
- We need a number divisible by: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
- That number is 2520
- 2520 ÷ 8 = 315, 2520 ÷ 9 = 280, etc. (all divide evenly)

## My Solution

```python
from functools import reduce
import math

def lcm(a: int, b: int) -> int:
    if a == b == 0:
        raise ValueError('Either a or b must be nonZero')
    return a * b // math.gcd(a, b)

def euler_05(n: int) -> int:
    return reduce(lcm, range(1, n + 1), 1)

# Find LCM of numbers 1 to 20
result = euler_05(20)
```

**Result:** `232792560`

## How This Solution Works

### The LCM Formula
```python
def lcm(a: int, b: int) -> int:
    return a * b // math.gcd(a, b)
```

This uses the fundamental relationship:
**LCM(a, b) × GCD(a, b) = a × b**

Therefore: **LCM(a, b) = (a × b) ÷ GCD(a, b)**

Examples:
- LCM(12, 8): GCD(12, 8) = 4, so LCM = 12 × 8 ÷ 4 = 24
- LCM(15, 10): GCD(15, 10) = 5, so LCM = 15 × 10 ÷ 5 = 30

### Error Handling
```python
if a == b == 0:
    raise ValueError('Either a or b must be nonZero')
```

This prevents division by zero since GCD(0, 0) is undefined mathematically.

### Using Reduce for Multiple LCMs
```python
reduce(lcm, range(1, n + 1), 1)
```

`reduce` applies the `lcm` function cumulatively:
- Start with initial value: `1`
- LCM(1, 1) = 1
- LCM(1, 2) = 2  
- LCM(2, 3) = 6
- LCM(6, 4) = 12
- LCM(12, 5) = 60
- ... and so on until 20

This efficiently computes: **LCM(1, 2, 3, 4, ..., 20)**

## Alternative Solutions

### Solution 1: Built-in LCM (Python 3.9+)
```python
from math import lcm
from functools import reduce

def euler_05_builtin(n: int) -> int:
    return reduce(lcm, range(1, n + 1))
```

### Solution 2: Iterative Approach
```python
def euler_05_iterative(n: int) -> int:
    result = 1
    for i in range(1, n + 1):
        result = lcm(result, i)
    return result
```

### Solution 3: Prime Factorization Method
```python
def euler_05_prime_factorization(n: int) -> int:
    """Most mathematically efficient approach."""
    from collections import defaultdict
    
    def prime_factors(num):
        factors = defaultdict(int)
        d = 2
        while d * d <= num:
            while num % d == 0:
                factors[d] += 1
                num //= d
            d += 1
        if num > 1:
            factors[num] += 1
        return factors
    
    # Find highest power of each prime needed
    max_powers = defaultdict(int)
    for i in range(2, n + 1):
        factors = prime_factors(i)
        for prime, power in factors.items():
            max_powers[prime] = max(max_powers[prime], power)
    
    # Calculate LCM as product of prime powers
    result = 1
    for prime, power in max_powers.items():
        result *= prime ** power
    
    return result
```

### Solution 4: Brute Force (Don't Use This!)
```python
def euler_05_brute_force(n: int) -> int:
    """Terribly inefficient - included for comparison."""
    candidate = n
    while True:
        if all(candidate % i == 0 for i in range(1, n + 1)):
            return candidate
        candidate += n  # At least jump by n each time
```

## Performance Comparison

```python
import time

def benchmark_solutions():
    n = 20
    solutions = [
        ("My Solution", lambda: euler_05(n)),
        ("Built-in LCM", lambda: euler_05_builtin(n)),
        ("Iterative", lambda: euler_05_iterative(n)),
        ("Prime Factorization", lambda: euler_05_prime_factorization(n)),
    ]
    
    for name, func in solutions:
        start = time.time()
        result = func()
        end = time.time()
        print(f"{name}: {result} ({end-start:.6f}s)")
```

**Typical Results:**
- **My Solution**: 232792560 (~0.000010s) - Excellent balance
- **Built-in LCM**: 232792560 (~0.000008s) - Slightly faster (if available)
- **Iterative**: 232792560 (~0.000012s) - Similar performance
- **Prime Factorization**: 232792560 (~0.000050s) - More complex but scales better

## Mathematical Deep Dive

### Why This Works: LCM Properties

The LCM has these key properties:
- **Associative**: LCM(LCM(a, b), c) = LCM(a, LCM(b, c))
- **Commutative**: LCM(a, b) = LCM(b, a)
- **Identity**: LCM(a, 1) = a

This means we can compute LCM of many numbers by repeatedly applying LCM to pairs.

### The Math Behind LCM(1, 2, 3, ..., 20)

Let's trace through smaller examples:

**LCM(1, 2, 3, 4):**
- LCM(1, 2) = 2
- LCM(2, 3) = 6  
- LCM(6, 4) = 12

**Why 12?** Because:
- 12 = 2² × 3¹
- Includes highest powers: 2² (from 4), 3¹ (from 3)

**For LCM(1, 2, ..., 20):**
- Prime factorization: 2⁴ × 3² × 5¹ × 7¹ × 11¹ × 13¹ × 17¹ × 19¹
- = 16 × 9 × 5 × 7 × 11 × 13 × 17 × 19 = 232,792,560

## Why I Love This Solution

1. **Mathematical Elegance**: Uses the fundamental LCM-GCD relationship
2. **Functional Programming**: `reduce` applies the operation elegantly
3. **Reusable**: Works for any range (not just 1-20)
4. **Efficient**: O(n log(max)) time complexity
5. **Error Handling**: Prevents edge cases with zero inputs
6. **Type Safety**: Proper type hints throughout

## Key Programming Concepts

- **functools.reduce**: Applying binary operations to sequences
- **Mathematical functions**: Using `math.gcd` effectively
- **Error handling**: Preventing invalid inputs
- **Algorithm efficiency**: Leveraging mathematical properties
- **Type hints**: Modern Python best practices

## Extending the Solution

### Make it More Flexible
```python
def lcm_range(start: int, end: int) -> int:
    """Find LCM of numbers in range [start, end]."""
    return reduce(lcm, range(start, end + 1), 1)

# Examples:
print(lcm_range(1, 10))   # 2520
print(lcm_range(5, 15))   # LCM of 5,6,7,8,9,10,11,12,13,14,15
print(lcm_range(1, 20))   # 232792560
```

### Add Verification
```python
def verify_solution(result: int, n: int) -> bool:
    """Verify that result is divisible by all numbers 1 to n."""
    return all(result % i == 0 for i in range(1, n + 1))

# Test our solution
result = euler_05(20)
print(f"Result: {result}")
print(f"Verified: {verify_solution(result, 20)}")
```

## Complete Working Code

```python
from functools import reduce
import math

def lcm(a: int, b: int) -> int:
    """Calculate Least Common Multiple of two numbers."""
    if a == b == 0:
        raise ValueError('Either a or b must be nonZero')
    return a * b // math.gcd(a, b)

def euler_05(n: int) -> int:
    """Find smallest positive number evenly divisible by all numbers 1 to n."""
    return reduce(lcm, range(1, n + 1), 1)

def verify_solution(result: int, n: int) -> bool:
    """Verify that result is divisible by all numbers 1 to n."""
    return all(result % i == 0 for i in range(1, n + 1))

if __name__ == "__main__":
    # Solve for 1 to 20
    result = euler_05(20)
    print(f"Smallest multiple of 1-20: {result}")
    print(f"Verification: {verify_solution(result, 20)}")
    
    # Show progression for smaller ranges
    for i in [5, 10, 15, 20]:
        lcm_result = euler_05(i)
        print(f"LCM(1 to {i:2d}): {lcm_result:,}")
```

## Test Your Understanding

1. **What's the LCM of numbers 1 to 30?** (Hint: it's much larger!)
2. **Can you modify the solution to find LCM of only even numbers 2, 4, 6, ..., 20?**
3. **What happens if you call `euler_05(0)` or `euler_05(1)`?**

---

*This is part of my Python Problem Solving series. Check out more solutions on my [GitHub](your-github-link)!*