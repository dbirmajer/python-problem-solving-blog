---
layout: post
title: "Project Euler Problem 12: Highly Divisible Triangular Number"
date: 2025-08-12
categories: [project-euler, number-theory, triangular-numbers]
tags: [python, prime-factorization, divisors, mathematics, itertools]
author: dbirmajer
excerpt: "Find the first triangular number with over 500 divisors using elegant Python and number theory."
---

# Project Euler Problem 12: Highly Divisible Triangular Number

## Problem Statement

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

- **1**: 1
- **3**: 1,3
- **6**: 1,2,3,6
- **10**: 1,2,5,10
- **15**: 1,3,5,15
- **21**: 1,3,7,21
- **28**: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

## The Elegant Solution

Here's my solution using Python's powerful libraries and mathematical insights:

```python
#!/usr/bin/env python3
"""
Project Euler Problem 12
"""

from math import prod
from itertools import (count, accumulate)
from more_itertools import first_true
from collections import Counter
from primePy import primes

def num_factors(n: int) -> int:
    return prod([a+1 for a in Counter(primes.factors(n)).values()])

triangular = accumulate(count(1))
print(first_true(triangular, pred=lambda t: num_factors(t) > 500))
```

**Result: 76,576,500**

## Understanding Triangular Numbers

### What Are Triangular Numbers?

Triangular numbers represent the sum of the first n natural numbers. They're called "triangular" because they can be arranged in triangular patterns:

```
1 = 1
3 = 1 + 2
6 = 1 + 2 + 3
10 = 1 + 2 + 3 + 4
```

Visually:
```
*
* *
* * *
* * * *
```

### Mathematical Formula

The nth triangular number is given by:
```
T_n = 1 + 2 + 3 + ... + n = n(n+1)/2
```

This formula comes from the fact that if you have two copies of a triangular arrangement, they form a rectangle of dimensions n × (n+1).

## The Mathematics Behind Counting Divisors

The key insight in this solution is using **prime factorization** to efficiently count divisors.

### Prime Factorization Method

If a number n has the prime factorization:
```
n = p₁^a₁ × p₂^a₂ × p₃^a₃ × ... × pₖ^aₖ
```

Then the number of divisors is:
```
d(n) = (a₁ + 1) × (a₂ + 1) × (a₃ + 1) × ... × (aₖ + 1)
```

### Why This Formula Works

Each divisor of n must have the form:
```
p₁^b₁ × p₂^b₂ × p₃^b₃ × ... × pₖ^bₖ
```

Where `0 ≤ bᵢ ≤ aᵢ` for each prime factor pᵢ.

For each prime pᵢ, we have (aᵢ + 1) choices for the exponent bᵢ: {0, 1, 2, ..., aᵢ}.

Since the choices for each prime are independent, we multiply the number of choices:
**(a₁ + 1) × (a₂ + 1) × ... × (aₖ + 1)**

### Example

Let's take the number 28:
```
28 = 2² × 7¹
```

Number of divisors = (2 + 1) × (1 + 1) = 3 × 2 = 6

The divisors are: 1, 2, 4, 7, 14, 28 ✓

## Code Breakdown

### 1. Generating Triangular Numbers
```python
triangular = accumulate(count(1))
```

- `count(1)` generates: 1, 2, 3, 4, 5, ...
- `accumulate()` creates running sums: 1, 3, 6, 10, 15, ...

This is more elegant than the explicit formula `n*(n+1)//2` because it leverages itertools.

### 2. Counting Factors Efficiently
```python
def num_factors(n: int) -> int:
    return prod([a+1 for a in Counter(primes.factors(n)).values()])
```

Let's break this down:

1. `primes.factors(n)` returns all prime factors (with repetition)
2. `Counter()` counts occurrences of each prime
3. `[a+1 for a in Counter(...).values()]` adds 1 to each exponent
4. `prod()` multiplies all the results

### Example Walkthrough
For n = 28:
```python
primes.factors(28)     # [2, 2, 7]
Counter([2, 2, 7])     # Counter({2: 2, 7: 1})
Counter(...).values()  # [2, 1]  (exponents)
[a+1 for a in ...]     # [3, 2]  (add 1 to each)
prod([3, 2])          # 6       (multiply them)
```

### 3. Finding the First Match
```python
first_true(triangular, pred=lambda t: num_factors(t) > 500)
```

This elegantly searches through the infinite generator of triangular numbers until it finds one with more than 500 divisors.

## Alternative Approaches

### Naive Brute Force (Don't Do This!)
```python
def count_divisors_naive(n):
    count = 0
    for i in range(1, n + 1):
        if n % i == 0:
            count += 1
    return count

# This would take forever for large numbers!
```

**Time Complexity**: O(n) per number - too slow!

### Optimized Brute Force
```python
def count_divisors_optimized(n):
    count = 0
    i = 1
    while i * i <= n:
        if n % i == 0:
            count += 1 if i * i == n else 2
        i += 1
    return count
```

**Time Complexity**: O(√n) per number - better, but still slow for very large triangular numbers.

### Prime Factorization (Our Method)
**Time Complexity**: O(√n) for factorization, but with much better constants due to optimized prime libraries.

## Performance Insights

The prime factorization method is superior because:

1. **Efficient Libraries**: `primePy.primes.factors()` uses optimized algorithms
2. **Mathematical Elegance**: Direct formula instead of trial division
3. **Scalability**: Handles large numbers efficiently

## Key Python Techniques Demonstrated

### 1. **Generator Composition**
```python
triangular = accumulate(count(1))
```
Creates an infinite sequence without storing values in memory.

### 2. **Functional Programming**
```python
first_true(triangular, pred=lambda t: num_factors(t) > 500)
```
Separates the "what" (finding first match) from the "how" (iteration logic).

### 3. **Mathematical Libraries**
- `math.prod()` for efficient multiplication
- `collections.Counter` for frequency counting
- `primePy` for prime factorization

### 4. **List Comprehension with Mathematical Formula**
```python
[a+1 for a in Counter(primes.factors(n)).values()]
```
Directly implements the divisor formula.

## Mathematical Beauty

This problem beautifully connects several mathematical concepts:

- **Triangular Numbers**: Geometric interpretation of arithmetic sequences
- **Prime Factorization**: Fundamental theorem of arithmetic
- **Divisor Function**: Number theory application
- **Combinatorics**: Counting principle for divisor calculation

## Extensions and Variations

Try these variations to deepen understanding:

```python
# Find triangular numbers with exactly k divisors
def find_triangular_with_k_divisors(k, limit=10):
    triangular = accumulate(count(1))
    matches = []
    for t in triangular:
        if num_factors(t) == k:
            matches.append(t)
        if len(matches) >= limit:
            break
    return matches

# Analyze divisor growth for triangular numbers
triangular = accumulate(count(1))
for i, t in enumerate(triangular, 1):
    if i > 100:
        break
    print(f"T_{i} = {t}, divisors = {num_factors(t)}")
```

## Final Thoughts

This problem showcases the power of combining:
1. **Mathematical insight** (prime factorization for counting divisors)
2. **Algorithmic efficiency** (generators and optimized libraries)
3. **Pythonic code** (functional programming and comprehensions)

The solution is both mathematically elegant and computationally efficient - demonstrating that the best solutions often come from understanding the underlying mathematics rather than just brute-forcing the computation.

---

**Links:**
- [Project Euler Problem 12](https://projecteuler.net/problem=12)
- [Triangular Numbers - Wikipedia](https://en.wikipedia.org/wiki/Triangular_number)
- [Divisor Function - Wikipedia](https://en.wikipedia.org/wiki/Divisor_function)
- [primePy Documentation](https://pypi.org/project/primePy/)